plugins {
    id "eclipse"
    id "idea"
    id "java-library"
    id "net.minecraftforge.gradle" version "6.0.25"
    id "org.spongepowered.mixin" version "0.7.+"
    id "me.modmuss50.mod-publish-plugin" version "0.5.2"
}

version = mod_version + "-forge-" + minecraft_suffix
group = maven_group
base.archivesName = mod_id

java.toolchain.languageVersion = JavaLanguageVersion.of(java_target)

println("Java: " + System.getProperty("java.version") + " JVM: " + System.getProperty("java.vm.version") + "(" + System.getProperty("java.vendor") + ") Arch: " + System.getProperty("os.arch"))

// Keep parameter names when compiling
compileJava.options.compilerArgs.add '-parameters'

repositories {
    flatDir { dirs "libs" }
    maven { url "https://www.cursemaven.com" }
    exclusiveContent {
        forRepository {
            maven { url = "https://api.modrinth.com/maven" }
        }
        filter { includeGroup "maven.modrinth" }
    }
    maven { url = "https://repo.spongepowered.org/maven" }
}

dependencies {
    // Forge
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

    // SpongePowered Mixin
    annotationProcessor "org.spongepowered:mixin:0.8.5:processor"
    implementation("org.spongepowered:mixin:0.8.2") {
        exclude module: "guava"
        exclude module: "commons-io"
        exclude module: "gson"
    }

    // SpongeForge
    compileOnly("org.spongepowered:spongeforge:1.12.2-2838-7.4.7") {
        transitive = false
    }
}

// Include resources generated by data generators.
sourceSets.main {
    resources.srcDir "src/generated/resources"
    // Make sure resources are available for 1.12
    output.setResourcesDir output.classesDirs.asPath
}

processResources {
    inputs.property "version", version

    // Replace the mod version
    Map<String, ?> copyProperties = project.properties.clone() as Map<String, ?>
    //noinspection UnnecessaryQualifiedReference
    var matcher = java.util.regex.Pattern.compile("[^.0-9]").matcher(copyProperties.mod_version as String)
    if (matcher.find())
        copyProperties.mod_version = copyProperties.mod_version.substring(0, matcher.start()) + "+" + copyProperties.mod_version.substring(matcher.start())

    filesMatching(["mcmod.info", "modid.mixins.json", "pack.mcmeta"]) {
        expand copyProperties
    }

    exclude "**/*.pdn"

    rename "^modid.mixins.json\$", "${mod_id}.mixins.json"
    rename "^icon.png\$", "${mod_id}.png"
    rename "^accesstransformer.cfg\$", "${mod_id}-accesstransformer.cfg"
}

minecraft {
    mappings channel: mappings_channel, version: mappings_version

    accessTransformer = file("src/main/resources/META-INF/accesstransformer.cfg")

    String resolved_core_plugin = "${mod_package}.${coremod_package}.${coremod_class}"
    String resolved_core_config = "${mod_id}.mixins.json"

    runs {
        configureEach {
            workingDirectory file("run")

            property "forge.logging.markers", "REGISTRIES"
            property "fml.coreMods.load", resolved_core_plugin

            args "--mixin", resolved_core_config

            mods {
                supermartijn642corelib {
                    //noinspection GroovyAssignabilityCheck
                    source sourceSets.main
                }
//                corelibtestmod {
//                    source sourceSets.test
//                }
            }
        }

        client {
        }

        server {
        }

        data {
            property "--generatorModid", mod_id
            property "--output", file("src/generated/resources/")
            //noinspection GroovyAssignabilityCheck
            property "--existing", layout.buildDirectory.file("/data_resources").map { it.asFile }.get()
        }
    }
}

tasks.register('processSources', Sync) {
    from sourceSets.main.java
    into layout.buildDirectory.dir("/sources")
    inputs.property 'version', version

    // Replace mod properties in main mod class
    Hashtable<String, String> properties = new Hashtable<>()
    project.properties.entrySet().stream()
            .filter(entry -> entry.key instanceof String && entry.value instanceof String)
            .forEach(entry -> properties.put(entry.key, entry.value as String))
    filesMatching(mod_package.replace('.', '/') + "/" + mod_main_class + ".java") {
        //noinspection UnnecessaryQualifiedReference
        filter(org.apache.tools.ant.filters.ReplaceTokens, tokens: properties)
    }
}

compileJava {
    source = processSources.outputs
}

mixin {
    // MixinGradle Settings
    add sourceSets.main, "${mod_id}.mixins.refmap.json"
}

// Rename the IntelliJ run configs
gradle.taskGraph.whenReady {
    tasks.genIntellijRuns.doLast {
        def configDir = it.getRunConfigurationsFolder().get().getAsFile()
        minecraft.runs.each {
            //noinspection GroovyAssignabilityCheck
            def configFile = new File(configDir, it.getUniqueFileName() + ".xml")
            if(configFile.exists()){
                def xml = new groovy.xml.XmlSlurper().parse(configFile)
                //noinspection GrUnresolvedAccess
                xml.configuration.@name = "Forge " + it.name.capitalize()
                configFile.withWriter { groovy.xml.XmlUtil.serialize(xml, it) }
            }
        }
    }
}

jar {
    from {
        configurations.compileClasspath
                .filter { "mixin-0.8.2.jar" == it.name }
                .collect { it.isDirectory() ? it : zipTree(it) }
    } {
        exclude "LICENSE.txt", "META-INF/MANIFSET.MF", "META-INF/maven/**", "META-INF/*.RSA", "META-INF/*.SF"
    }

    manifest {
        attributes "FMLCorePlugin": "com.supermartijn642.core.coremod.CoreModPlugin"
        attributes "FMLCorePluginContainsFMLMod": "true"
        attributes "ForceLoadAsMod": "true"
        attributes "TweakClass": "org.spongepowered.asm.launch.MixinTweaker"
        attributes "TweakOrder": "0"
        attributes "MixinConfigs": "supermartijn642corelib.mixins.json"
    }
}

//jar.finalizedBy('reobfJar')

tasks.register('javadocJar', Jar) {
    dependsOn javadoc
    group = "documentation"
    archiveClassifier = "javadoc"
    from javadoc.destinationDir
}

tasks.register('sourcesJar', Jar) {
    dependsOn classes
    group = "documentation"
    archiveClassifier = "sources"
    from sourceSets.main.allSource
}

tasks.register('prepareDataResources', Sync) {
    from file("src/main/resources")
    into layout.buildDirectory.dir("/data_resources")
    inputs.property "version", version

    // Replace the mod version
    Map<String, ?> copyProperties = project.properties.clone() as Map<String, ?>
    //noinspection UnnecessaryQualifiedReference
    var matcher = java.util.regex.Pattern.compile("[^.0-9]").matcher(copyProperties.mod_version as String)
    if (matcher.find())
        copyProperties.mod_version = copyProperties.mod_version.substring(0, matcher.start()) + "+" + copyProperties.mod_version.substring(matcher.start())

    filesMatching(["mcmod.info", "modid.mixins.json", "pack.mcmeta"]) {
        expand copyProperties
    }

    exclude "**/*.pdn"

    rename "^modid.mixins.json\$", "${mod_id}.mixins.json"
    rename "^icon.png\$", "${mod_id}.png"
    rename "^accesstransformer.cfg\$", "${mod_id}-accesstransformer.cfg"
}

// Run prepareDataResources before prepareRunData
tasks.configureEach {
    if (it.name == "prepareRunData" || it.name == "prepareRunDataCompile")
        it.dependsOn "prepareDataResources"
}

// Force the jar to be reobfuscated
jar.finalizedBy('reobfJar')

// Create task which copies from 'jar', but renames the file
tasks.register('renameJar', Copy) {
    dependsOn build
    from jar
    into 'build/renamedLibs'
    rename "_"::concat
}
jar.finalizedBy renameJar

publishMods {
    file = file('build/renamedLibs/_' + jar.getArchiveFileName().get())
    displayName = "${mod_name} ${mod_version} for Forge ${minecraft_suffix.substring(2)}"
    version = project.version
    //noinspection UnnecessaryQualifiedReference
    type = me.modmuss50.mpp.ReleaseType.of(publishing_release_type.toUpperCase())
    changelog = file("changelog.md").text
    modLoaders.add("forge")
    maxRetries = 2

    curseforge {
        accessToken = System.getenv("CURSEFORGE_TOKEN")
        projectId = curseforge_project_id
        if (!curseforge_required_dependency_ids.isEmpty())
            curseforge_required_dependency_ids.split(" ").each it::requires
        if (!curseforge_optional_dependency_ids.isEmpty())
            curseforge_optional_dependency_ids.split(" ").each it::optional
        publishing_game_versions.split(" ").each minecraftVersions::add
        clientRequired = true
        serverRequired = true
    }

    modrinth {
        accessToken = System.getenv("MODRINTH_TOKEN")
        projectId = modrinth_project_id
        displayName = "${mod_name} ${mod_version}"
        if (!modrinth_required_dependency_ids.isEmpty())
            modrinth_required_dependency_ids.split(" ").each it::requires
        if (!modrinth_optional_dependency_ids.isEmpty())
            modrinth_optional_dependency_ids.split(" ").each it::optional
        publishing_game_versions.split(" ").each minecraftVersions::add
    }
}

// Rename the 'publishMods' task
tasks.publishMods.group = "other"
tasks.register("publishAll") {
    group = "publishing"
    dependsOn(tasks.publishMods)
}
